# SCA Findings Analysis

## Overview
The methodology used to prioritize vulnerabilities combines **CVSS** (severity score) with **EPSS** (Exploit Prediction Scoring System).  
Instead of using solely the **CVSS**, I enriched the analysis by checking the probability of exploitation (**EPSS**) for each CVE detected by SCA. For this purpose, I developed the script [osv-parser.py](https://github.com/paulocesarmsf/appsec_security_pipeline/blob/main/SCA/osv-parser.py), because:
  

- The JSON output generated by [OSV Scanner](https://github.com/google/osv-scanner) can become **large and complex**, making it difficult to extract relevant data directly.  
- It was necessary to get **EPSS scores** using the [FIRST API](https://api.first.org/data/v1/epss?cve=<CVE>), correlating CVEs with their exploitation probability.  
- This script parses OSV results, retrieves EPSS values, and exports a simplified [CSV file](https://github.com/paulocesarmsf/appsec_security_pipeline/blob/main/SCA/parsed-vulnerabilities.csv) with package, version, CVE, CVSS, and EPSS.  

**Ps:** Details on how to run the script are included inside the script itself.

## Summary

| Package       | Version | CVE            | CVSS | EPSS   | Severity |
|---------------|---------|----------------|------|--------|----------|
| json5         | 2.2.1   | CVE-2022-46175 | 7.1  | 0.4049 | High     |
| certifi       | 2024.2.2| CVE-2024-39689 | 7.5  | 0.2123 | High     |
| loader-utils  | 2.0.2   | CVE-2022-37601 | 9.8  | 0.1584 | Critical |

## Finding 1: json5:2.2.1 - CVE-2022-46175

**Description:**  
  Prototype pollution in JSON5 via the `parse` method.  
  The package does not restrict keys like `__proto__`, allowing crafted input to modify the prototype of the resulting object. This can let attackers alter application properties, leading to unexpected behavior, data tampering, or security bypasses.  

**Severity**
- **CVSS:** 7.1 (High)  
- **EPSS:** 0.4049 (high probability of exploitation)  

This vulnerability is prioritized because it combines **high severity** with one of the **highest exploitation likelihoods (EPSS)**, making it a practical risk in real-world scenarios.  

**Exploitation Scenario**  
GitHub Advisory has a brilliant **[POC](https://github.com/json5/json5/security/advisories/GHSA-9c47-m6qq-7p4h)** to explain the exploitation scenario.  

But let's try to simplify it even further: 
- Imagine an app that decides what to do based on the user's role, for example an administrative action:
```js
const doSomethingAsAdmin = (user) => {
  if (user.isAdmin) {
    console.log('Doing thing as admin')
  } else {
    console.log('Action not allowed, you are not an admin')
  }
}
```
- An attacker could try exploit Prototype Pollution using the special __proto__ key:
```js
const JSON5 = require('json5');
const user = JSON5.parse('{"foo": "bar", "__proto__": {"isAdmin": true}}');
doSomethingAsAdmin(user); 
// Output: "Doing thing as admin"
```
- In this case, the attacker pollutes the object prototype, making isAdmin resolve to true and bypassing the intended admin check.

**Mitigation Recommendations**  
  - Upgrade to a patched version of `json5` (≥ 2.2.2 or the latest available release).  
  - Validate and sanitize all untrusted JSON input before processing.  
  - **Use SCA tools and analyze your SBOM** to identify and continuously monitor vulnerable dependencies across all apps that include `json5` package.

## Finding 2: certifi:2024.2.2 - CVE-2024-39689

**Description:**  
A vulnerability was identified in the `certifi` package, which provides Mozilla’s trusted root certificates for Python applications.  
This issue may allow applications to rely on outdated or unsafe certificate bundles, potentially exposing them to **man-in-the-middle (MITM) attacks** or other trust-related risks if invalid certificates are not properly rejected.

**Severity**
- **CVSS:** 7.5 (High)  
- **EPSS:** 0.2123 (moderate probability of exploitation)  

This vulnerability is prioritized because `certifi` is a widely used package in the Python ecosystem. A compromise or misconfiguration in root certificates can have a broad impact across multiple applications.  

*Exploitation Scenario**  
- Imagine an application that uses `certifi` to validate HTTPS requests.  
- If the certificate bundle is outdated or incorrectly validated, an attacker could present a malicious certificate chain and potentially bypass TLS verification.  
- This could enable interception or manipulation of supposedly secure communications.  

**Mitigation Recommendations**  
- Upgrade to `certifi` ≥ 2024.7.4, which removes the untrusted GLOBALTRUST root certificates and addresses.
- Regularly update and monitor the certificate bundle to ensure applications use trusted root certificates.  
- **Use SCA tools and analyze your SBOM** to track dependencies like `certifi` across all applications, ensuring they remain up to date.  

## Finding 3: loader-utils:2.0.2 - CVE-2022-37601

**Description:**  
Prototype pollution vulnerability in `webpack loader-utils` prior to version 2.0.3.  
The issue exists in the `parseQuery` function of `parseQuery.js`, where untrusted input passed through the `name` variable is not properly sanitized.  
This allows attackers to inject properties like `__proto__`, leading to prototype pollution and manipulation of application behavior during the webpack build process. 

**Severity**
- **CVSS:** 9.8 (Critical)  
- **EPSS:** 0.1584 (moderate probability of exploitation)  

This vulnerability is prioritized because it has a **critical CVSS score** (9.8) and affects a package commonly used in the JavaScript/webpack ecosystem.  
Even with a moderate EPSS, the high severity means exploitation could have a devastating impact if triggered.  

**Exploitation Scenario**  
Developers usually don’t use `loader-utils` directly, but it is included as a dependency of many webpack loaders (like `file-loader`, `url-loader`, `sass-loader`).
Let’s see a case in real life:  

- **Supply chain attack:**  
  An attacker publishes or contributes a package that internally configures webpack with malicious query parameters.  
  When the victim project installs the package and runs the build, the malicious payload is passed to `parseQuery()`.  
  Using `?__proto__[isAdmin]=true`, the attacker pollutes the global object prototype, potentially bypassing security checks or manipulating logic across the build process.  

**Simplified PoC:**  
```js
const { parseQuery } = require('loader-utils');

// Normal usage
console.log(parseQuery('?foo=bar')); 
// -> { foo: "bar" }

// Malicious payload
console.log(parseQuery('?__proto__[isAdmin]=true')); 
// -> {} but now ({}).isAdmin === true for all objects
```

**Mitigation Recommendations**  
- Upgrade to a patched version of `loader-utils` (≥ 2.0.3 or the latest available release).  
- Avoid processing untrusted input in build tools.  
- **Use SCA tools and analyze your SBOM** to detect and monitor vulnerable versions of `loader-utils` across all projects.  
